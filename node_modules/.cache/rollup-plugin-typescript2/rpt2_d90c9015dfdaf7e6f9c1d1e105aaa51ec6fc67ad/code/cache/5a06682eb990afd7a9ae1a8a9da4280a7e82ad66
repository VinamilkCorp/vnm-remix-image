{"code":"import mimeFromBuffer from \"mime-tree\";\nimport { MimeType, UnsupportedImageError } from \"../../types\";\nimport { RemixImageError } from \"../../types/error\";\nimport { imageResponse, textResponse, redirectResponse, } from \"../../utils/response\";\nimport { decodeQuery, decodeTransformQuery, parseURL } from \"../../utils/url\";\nimport { pureTransformer } from \"../transformers\";\nexport const imageLoader = async ({ selfUrl, cache = null, resolver, transformer = pureTransformer, useFallbackFormat = true, fallbackFormat, useFallbackTransformer = true, fallbackTransformer = pureTransformer, defaultOptions = {}, redirectOnFail = false, skipFormats = new Set([MimeType.SVG]), basePath = \"public\", whitelistedDomains = null, blacklistedDomains = null, verbose = false, }, request) => {\n    const reqUrl = parseURL(request.url);\n    let src = null;\n    try {\n        if (!selfUrl) {\n            throw new RemixImageError(\"selfUrl is required in RemixImage loader config!\", 500);\n        }\n        let selfUrlObj;\n        try {\n            selfUrlObj = new URL(selfUrl);\n        }\n        catch (error) {\n            throw new RemixImageError(\"selfUrl is not a valid URL!\");\n        }\n        const whitelist = whitelistedDomains\n            ? new Set([...whitelistedDomains, selfUrlObj.host])\n            : null;\n        const blacklist = blacklistedDomains ? new Set(blacklistedDomains) : null;\n        src = decodeQuery(reqUrl.searchParams, \"src\");\n        if (!src) {\n            throw new RemixImageError(\"An image URL must be provided!\", 400);\n        }\n        try {\n            src = decodeURI(src);\n        }\n        catch (error) {\n            throw new RemixImageError(\"An invalid image URL was provided!\", 400);\n        }\n        const decodedQuery = decodeTransformQuery(reqUrl.search);\n        const transformOptions = {\n            fit: \"cover\",\n            position: \"center\",\n            background: [0x00, 0x00, 0x00, 0x00],\n            quality: 80,\n            compressionLevel: 9,\n            loop: 0,\n            delay: 100,\n            blurRadius: null,\n            rotate: null,\n            flip: null,\n            crop: null,\n            ...defaultOptions,\n            ...decodedQuery,\n        };\n        const assetUrl = parseURL(src, selfUrl);\n        if (!transformOptions.width) {\n            throw new RemixImageError(\"A width is required!\", 400);\n        }\n        if (transformOptions.width && transformOptions.width > 8000) {\n            throw new RemixImageError(\"Requested Image too large!\", 406);\n        }\n        if (transformOptions.height && transformOptions.height > 8000) {\n            throw new RemixImageError(\"Requested Image too large!\", 406);\n        }\n        const cacheKey = reqUrl.search;\n        let isNewImage = true;\n        let shouldTransform = true;\n        let loadedImg;\n        let resultImg;\n        let inputContentType;\n        let outputContentType = transformOptions.contentType;\n        if (cache && (await cache.has(cacheKey))) {\n            const cacheValue = await cache.get(cacheKey);\n            if (cacheValue) {\n                if (verbose) {\n                    console.log(`Retrieved image [${cacheKey}] from cache.`);\n                }\n                isNewImage = false;\n                shouldTransform = false;\n                loadedImg = cacheValue;\n                inputContentType = mimeFromBuffer(loadedImg);\n            }\n        }\n        if (!loadedImg) {\n            if (whitelist && !whitelist.has(assetUrl.host)) {\n                throw new RemixImageError(\"The requested image host is not included on the whitelist!\");\n            }\n            if (blacklist && blacklist.has(assetUrl.host)) {\n                throw new RemixImageError(\"The requested image host is not allowed!\");\n            }\n            const res = await resolver?.(src, assetUrl.toString(), transformOptions, basePath);\n            if (verbose) {\n                console.log(`Fetched image [${cacheKey}] directly using resolver: ${resolver?.name}.`);\n            }\n            isNewImage = true;\n            shouldTransform = true;\n            loadedImg = res?.buffer;\n            inputContentType = res?.contentType;\n        }\n        if (!loadedImg || !inputContentType) {\n            throw new RemixImageError(\"Failed to transform requested image!\", 500);\n        }\n        if (!outputContentType) {\n            outputContentType = inputContentType;\n        }\n        if (!shouldTransform || skipFormats?.has(inputContentType)) {\n            resultImg = loadedImg;\n        }\n        else if (transformer != null) {\n            let curTransformer = transformer;\n            if (!transformer.supportedInputs.has(inputContentType)) {\n                if (useFallbackTransformer &&\n                    transformer !== fallbackTransformer &&\n                    fallbackTransformer.supportedInputs.has(inputContentType)) {\n                    console.error(`Transformer does not allow this input content type: ${inputContentType}! Falling back to transformer: ${fallbackTransformer.name}`);\n                    curTransformer = fallbackTransformer;\n                }\n                else {\n                    throw new UnsupportedImageError(`Transformer does not allow this input content type: ${inputContentType}!`);\n                }\n            }\n            if (!curTransformer.supportedOutputs.has(outputContentType)) {\n                if (useFallbackFormat &&\n                    fallbackFormat != null &&\n                    curTransformer.supportedOutputs.has(fallbackFormat)) {\n                    console.error(`Transformer does not allow this output content type: ${outputContentType}! Falling back to mime type: ${fallbackFormat}`);\n                    outputContentType = fallbackFormat;\n                }\n                else {\n                    console.error(`Transformer does not allow this output content type: ${outputContentType}! Falling back to mime type: ${curTransformer.fallbackOutput}`);\n                    outputContentType = curTransformer.fallbackOutput;\n                }\n            }\n            resultImg = await curTransformer.transform({\n                url: assetUrl.toString(),\n                data: loadedImg,\n                contentType: inputContentType,\n            }, {\n                ...transformOptions,\n                contentType: outputContentType,\n            });\n            if (verbose) {\n                console.log(`Successfully transformed image using transformer: ${curTransformer.name}`);\n            }\n        }\n        if (!resultImg) {\n            throw new RemixImageError(\"Failed to transform requested image!\", 500);\n        }\n        if (isNewImage && cache) {\n            await cache.set(cacheKey, resultImg);\n        }\n        return imageResponse(resultImg, 200, outputContentType, cache\n            ? `private, max-age=${cache.config.ttl}, max-stale=${cache.config.tbd}`\n            : `public, max-age=${60 * 60 * 24 * 365}`);\n    }\n    catch (error) {\n        if (typeof process !== \"undefined\" && process?.env?.NODE_ENV === \"test\") {\n            throw error;\n        }\n        console.error(\"RemixImage loader error:\", error?.message);\n        console.error(error);\n        if (redirectOnFail && src) {\n            return redirectResponse(src);\n        }\n        if (error instanceof RemixImageError) {\n            return textResponse(error.errorCode || 500, error.message);\n        }\n        else {\n            return textResponse(500, \"RemixImage encountered an unknown error!\");\n        }\n    }\n};\n","references":["/Users/hnanh/Workspaces/remix-image/node_modules/mime-tree/build/index.d.ts","/Users/hnanh/Workspaces/remix-image/src/types/index.ts","/Users/hnanh/Workspaces/remix-image/src/types/error.ts","/Users/hnanh/Workspaces/remix-image/src/types/loader.ts","/Users/hnanh/Workspaces/remix-image/src/utils/response.ts","/Users/hnanh/Workspaces/remix-image/src/utils/url.ts","/Users/hnanh/Workspaces/remix-image/src/server/transformers/index.ts"],"dts":{"name":"/Users/hnanh/Workspaces/remix-image/build/server/loaders/imageLoader.d.ts","writeByteOrderMark":false,"text":"import type { AssetLoader } from \"../../types/loader\";\nexport declare const imageLoader: AssetLoader;\n"}}
